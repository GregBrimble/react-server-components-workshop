/*
 React
 eslint-plugin-react-hooks.production.min.js

 Copyright (c) Meta Platforms, Inc. and affiliates.

 This source code is licensed under the MIT license found in the
 LICENSE file in the root directory of this source tree.
*/
'use strict';function ha(a,c){if(a){if("string"===typeof a)return ma(a,c);var f=Object.prototype.toString.call(a).slice(8,-1);"Object"===f&&a.constructor&&(f=a.constructor.name);if("Map"===f||"Set"===f)return Array.from(a);if("Arguments"===f||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(f))return ma(a,c)}}function ma(a,c){if(null==c||c>a.length)c=a.length;for(var f=0,q=Array(c);f<c;f++)q[f]=a[f];return q}
function N(a,c){var f;if("undefined"===typeof Symbol||null==a[Symbol.iterator]){if(Array.isArray(a)||(f=ha(a))||c&&a&&"number"===typeof a.length){f&&(a=f);var q=0;c=function(){};return{s:c,n:function(){return q>=a.length?{done:!0}:{done:!1,value:a[q++]}},e:function(h){throw h;},f:c}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var v=!0,G=!1,t;return{s:function(){f=a[Symbol.iterator]()},
n:function(){var h=f.next();v=h.done;return h},e:function(h){G=!0;t=h},f:function(){try{v||null==f.return||f.return()}finally{if(G)throw t;}}}}function na(a){if("Identifier"===a.type)return a=a.name,a="use"===a||/^use[A-Z0-9]/.test(a),a;if("MemberExpression"===a.type&&!a.computed&&na(a.property)){a=a.object;var c=/^[A-Z].*/;return"Identifier"===a.type&&c.test(a.name)}return!1}function oa(a){return"Identifier"===a.type&&/^[A-Z]/.test(a.name)}
function pa(a,c){return a.name===c||"MemberExpression"===a.type&&"React"===a.object.name&&a.property.name===c}function qa(a){return!!(a.parent&&a.parent.callee&&pa(a.parent.callee,"forwardRef"))}function ua(a){return!!(a.parent&&a.parent.callee&&pa(a.parent.callee,"memo"))}function va(a){for(;a;){var c=wa(a);if(c&&(oa(c)||na(c))||qa(a)||ua(a))return!0;a=a.parent}return!1}function xa(a){return"Identifier"===a.type&&"useEffectEvent"===a.name}
function ya(a){return"Identifier"===a.type&&"use"===a.name}
function wa(a){if("FunctionDeclaration"===a.type||"FunctionExpression"===a.type&&a.id)return a.id;if("FunctionExpression"===a.type||"ArrowFunctionExpression"===a.type)return"VariableDeclarator"===a.parent.type&&a.parent.init===a?a.parent.id:"AssignmentExpression"===a.parent.type&&a.parent.right===a&&"="===a.parent.operator?a.parent.left:"Property"!==a.parent.type||a.parent.value!==a||a.parent.computed?"AssignmentPattern"!==a.parent.type||a.parent.right!==a||a.parent.computed?void 0:a.parent.left:
a.parent.key}
function za(a){function c(){return{isUsed:!1,isSatisfiedRecursively:!1,isSubtreeUsed:!1,children:new Map}}function f(k,n){n=n.split(".");n=N(n);var D;try{for(n.s();!(D=n.n()).done;){var H=D.value,I=k.children.get(H);I||(I=c(),k.children.set(H,I));k=I}}catch(J){n.e(J)}finally{n.f()}return k}function q(k,n,D){n=n.split(".");n=N(n);var H;try{for(n.s();!(H=n.n()).done;){var I=k.children.get(H.value);if(!I)break;D(I);k=I}}catch(J){n.e(J)}finally{n.f()}}function v(k,n,D,H){k.children.forEach(function(I,J){var S=
H(J);I.isSatisfiedRecursively?I.isSubtreeUsed&&D.add(S):I.isUsed?n.add(S):v(I,n,D,function(R){return S+"."+R})})}var G=a.dependencies,t=a.declaredDependencies,h=a.stableDependencies,z=a.externalDependencies,K=a.isEffect,x=c();G.forEach(function(k,n){f(x,n).isUsed=!0;q(x,n,function(D){D.isSubtreeUsed=!0})});t.forEach(function(k){f(x,k.key).isSatisfiedRecursively=!0});h.forEach(function(k){f(x,k).isSatisfiedRecursively=!0});a=new Set;var M=new Set;v(x,a,M,function(k){return k});var m=[],p=new Set,w=
new Set;t.forEach(function(k){k=k.key;M.has(k)?-1===m.indexOf(k)?m.push(k):w.add(k):!K||k.endsWith(".current")||z.has(k)?p.add(k):-1===m.indexOf(k)&&m.push(k)});a.forEach(function(k){m.push(k)});return{suggestedDependencies:m,unnecessaryDependencies:p,duplicateDependencies:w,missingDependencies:a}}
function V(a){switch(a.type){case "ObjectExpression":return"object";case "ArrayExpression":return"array";case "ArrowFunctionExpression":case "FunctionExpression":return"function";case "ClassExpression":return"class";case "ConditionalExpression":if(null!=V(a.consequent)||null!=V(a.alternate))return"conditional";break;case "LogicalExpression":if(null!=V(a.left)||null!=V(a.right))return"logical expression";break;case "JSXFragment":return"JSX fragment";case "JSXElement":return"JSX element";case "AssignmentExpression":if(null!=
V(a.right))return"assignment expression";break;case "NewExpression":return"object construction";case "Literal":if(a.value instanceof RegExp)return"regular expression";break;case "TypeCastExpression":case "AsExpression":case "TSAsExpression":return V(a.expression)}return null}
function Aa(a){var c=a.declaredDependenciesNode,f=a.componentScope,q=a.scope;return a.declaredDependencies.map(function(v){var G=v.key;v=f.variables.find(function(z){return z.name===G});if(null==v)return null;var t=v.defs[0];if(null==t)return null;if("Variable"===t.type&&"VariableDeclarator"===t.node.type&&"Identifier"===t.node.id.type&&null!=t.node.init){var h=V(t.node.init);if(null!=h)return[v,h]}return"FunctionName"===t.type&&"FunctionDeclaration"===t.node.type?[v,"function"]:"ClassName"===t.type&&
"ClassDeclaration"===t.node.type?[v,"class"]:null}).filter(Boolean).map(function(v){var G=v[0];v=v[1];var t=G.defs[0];a:{for(var h=!1,z=0;z<G.references.length;z++){var K=G.references[z];if(K.writeExpr)if(h){G=!0;break a}else{h=!0;continue}for(var x=K.from;x!==q&&null!=x;)x=x.upper;if(x!==q&&!Ba(c,K.identifier)){G=!0;break a}}G=!1}return{construction:t,depType:v,isUsedOutsideOfHook:G}})}
function Ca(a){return"MemberExpression"!==a.parent.type&&"OptionalMemberExpression"!==a.parent.type||a.parent.object!==a||"current"===a.parent.property.name||a.parent.computed||null!=a.parent.parent&&("CallExpression"===a.parent.parent.type||"OptionalCallExpression"===a.parent.parent.type)&&a.parent.parent.callee===a.parent?"MemberExpression"===a.type&&a.parent&&"AssignmentExpression"===a.parent.type&&a.parent.left===a?a.object:a:Ca(a.parent)}
function Da(a,c,f){c&&(a.optional?c.has(f)||c.set(f,!0):c.set(f,!1))}
function Z(a,c){if("Identifier"===a.type||"JSXIdentifier"===a.type)return a=a.name,c&&c.set(a,!1),a;if("MemberExpression"!==a.type||a.computed){if("OptionalMemberExpression"!==a.type||a.computed){if("ChainExpression"!==a.type||a.computed)throw Error("Unsupported node type: "+a.type);a=a.expression;if("CallExpression"===a.type)throw Error("Unsupported node type: "+a.type);var f=Z(a.object,c),q=Z(a.property,null);f=f+"."+q;Da(a,c,f);return f}f=Z(a.object,c);q=Z(a.property,null);f=f+"."+q;Da(a,c,f);
return f}f=Z(a.object,c);q=Z(a.property,null);f=f+"."+q;Da(a,c,f);return f}function Ea(a){return"MemberExpression"!==a.type||"Identifier"!==a.object.type||"React"!==a.object.name||"Identifier"!==a.property.type||a.computed?a:a.property}
function Ha(a,c){var f=Ea(a);if("Identifier"!==f.type)return-1;switch(f.name){case "useEffect":case "useLayoutEffect":case "useCallback":case "useMemo":return 0;case "useImperativeHandle":return 1;default:if(f===a&&c&&c.additionalHooks){try{var q=Z(f,null)}catch(v){if(/Unsupported node type/.test(v.message))return 0;throw v;}return c.additionalHooks.test(q)?0:-1}return-1}}
function Ia(a,c){for(var f=[a],q=null;f.length;){q=f.shift();if(("Identifier"===q.type||"JSXIdentifier"===q.type)&&q.type===c.type&&q.name===c.name&&q.range[0]===c.range[0]&&q.range[1]===c.range[1])return q;if(Ba(q,c)){a=0;for(var v=Object.entries(q);a<v.length;a++){var G=v[a],t=G[1];"parent"!==G[0]&&(Ja(t)?(t.parent=q,f.push(t)):Array.isArray(t)&&t.forEach(function(h){Ja(h)&&(h.parent=q,f.push(h))}))}}}return null}
function Ka(a){for(var c="",f=0;f<a.length;f++)c+=a[f],0===f&&2===a.length?c+=" and ":f===a.length-2&&2<a.length?c+=", and ":f<a.length-1&&(c+=", ");return c}function Ja(a){return"object"===typeof a&&null!==a&&!Array.isArray(a)&&"string"===typeof a.type}function Ba(a,c){return a.range[0]<=c.range[0]&&a.range[1]>=c.range[1]}exports.configs={recommended:{plugins:["react-hooks"],rules:{"react-hooks/rules-of-hooks":"error","react-hooks/exhaustive-deps":"warn"}}};
exports.rules={"rules-of-hooks":{meta:{type:"problem",docs:{description:"enforces the Rules of Hooks",recommended:!0,url:"https://reactjs.org/docs/hooks-rules.html"}},create:function(a){function c(h){h=N(h.references);var z;try{for(h.s();!(z=h.n()).done;){var K=z.value,x=K.identifier.parent;if("VariableDeclarator"===x.type&&x.init&&"CallExpression"===x.init.type&&x.init.callee&&xa(x.init.callee)){var M=N(K.resolved.references),m;try{for(M.s();!(m=M.n()).done;){var p=m.value;p!==K&&G.add(p.identifier)}}catch(w){M.e(w)}finally{M.f()}}}}catch(w){h.e(w)}finally{h.f()}}
var f=null,q=[],v=[],G=new WeakSet,t={};return t.onCodePathSegmentStart=function(h){return v.push(h)},t.onCodePathSegmentEnd=function(){return v.pop()},t.onCodePathStart=function(){return q.push(new Map)},t.onCodePathEnd=function(h,z){function K(l,B){var A=K.cache,y=A.get(l.id);B=new Set(B);if(B.has(l.id)){A=[].concat(B);l=A.slice(A.indexOf(l.id)+1);l=N(l);var E;try{for(l.s();!(E=l.n()).done;)p.add(E.value)}catch(O){l.e(O)}finally{l.f()}return BigInt("0")}B.add(l.id);if(void 0!==y)return y;if(h.thrownSegments.includes(l))y=
BigInt("0");else if(0===l.prevSegments.length)y=BigInt("1");else{y=BigInt("0");E=N(l.prevSegments);var C;try{for(E.s();!(C=E.n()).done;)y+=K(C.value,B)}catch(O){E.e(O)}finally{E.f()}}l.reachable&&y===BigInt("0")?A.delete(l.id):A.set(l.id,y);return y}function x(l,B){var A=x.cache,y=A.get(l.id);B=new Set(B);if(B.has(l.id)){A=Array.from(B);l=A.slice(A.indexOf(l.id)+1);l=N(l);var E;try{for(l.s();!(E=l.n()).done;)p.add(E.value)}catch(O){l.e(O)}finally{l.f()}return BigInt("0")}B.add(l.id);if(void 0!==y)return y;
if(h.thrownSegments.includes(l))y=BigInt("0");else if(0===l.nextSegments.length)y=BigInt("1");else{y=BigInt("0");E=N(l.nextSegments);var C;try{for(E.s();!(C=E.n()).done;)y+=x(C.value,B)}catch(O){E.e(O)}finally{E.f()}}A.set(l.id,y);return y}function M(l){var B=M.cache,A=B.get(l.id);if(null===A)return Infinity;if(void 0!==A)return A;B.set(l.id,null);if(0===l.prevSegments.length)A=1;else{A=Infinity;var y=N(l.prevSegments),E;try{for(y.s();!(E=y.n()).done;){var C=M(E.value);C<A&&(A=C)}}catch(O){y.e(O)}finally{y.f()}A+=
1}B.set(l.id,A);return A}var m=q.pop();if(0!==m.size){var p=new Set;K.cache=new Map;x.cache=new Map;M.cache=new Map;var w=x(h.initialSegment),k=wa(z),n=va(z),D=k?oa(k)||na(k):qa(z)||ua(z),H=Infinity,I=N(h.finalSegments),J;try{for(I.s();!(J=I.n()).done;){var S=J.value;if(S.reachable){var R=M(S);R<H&&(H=R)}}}catch(l){I.e(l)}finally{I.f()}m=N(m);var P;try{for(m.s();!(P=m.n()).done;){var ca=P.value,T=ca[0],ra=ca[1];if(T.reachable){var ia=0===T.nextSegments.length?H<=M(T):H<M(T),Q=K(T)*x(T),fa=p.has(T.id),
Y=N(ra),aa;try{for(Y.s();!(aa=Y.n()).done;){var F=aa.value;fa&&!ya(F)&&a.report({node:F,message:'React Hook "'+a.getSource(F)+'" may be executed more than once. Possibly because it is called in a loop. React Hooks must be called in the exact same order in every component render.'});if(D){if(z.async&&a.report({node:F,message:'React Hook "'+a.getSource(F)+'" cannot be called in an async function.'}),!fa&&Q!==w&&!ya(F)){var ba='React Hook "'+a.getSource(F)+'" is called conditionally. React Hooks must be called in the exact same order in every component render.'+
(ia?" Did you accidentally call a React Hook after an early return?":"");a.report({node:F,message:ba})}}else if(z.parent&&("MethodDefinition"===z.parent.type||"ClassProperty"===z.parent.type)&&z.parent.value===z){var L='React Hook "'+a.getSource(F)+'" cannot be called in a class component. React Hooks must be called in a React function component or a custom React Hook function.';a.report({node:F,message:L})}else if(k){var U='React Hook "'+a.getSource(F)+'" is called in function "'+(a.getSource(k)+
'" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word "use".');a.report({node:F,message:U})}else if("Program"===z.type){var ja='React Hook "'+a.getSource(F)+'" cannot be called at the top level. React Hooks must be called in a React function component or a custom React Hook function.';a.report({node:F,message:ja})}else if(n&&!ya(F)){var da='React Hook "'+a.getSource(F)+'" cannot be called inside a callback. React Hooks must be called in a React function component or a custom React Hook function.';
a.report({node:F,message:da})}}}catch(l){Y.e(l)}finally{Y.f()}}}}catch(l){m.e(l)}finally{m.f()}}},t.CallExpression=function(h){if(na(h.callee)){var z=q[q.length-1],K=v[v.length-1],x=z.get(K);x||(x=[],z.set(K,x));x.push(h.callee)}"Identifier"===h.callee.type&&("useEffect"===h.callee.name||xa(h.callee))&&0<h.arguments.length&&(f=h)},t.Identifier=function(h){null==f&&G.has(h)&&"CallExpression"!==h.parent.type&&a.report({node:h,message:"`"+a.getSource(h)+'` is a function created with React Hook "useEffectEvent", and can only be called from the same component. They cannot be assigned to variables or passed down.'})},
t["CallExpression:exit"]=function(h){h===f&&(f=null)},t.FunctionDeclaration=function(h){va(h)&&c(a.getScope())},t.ArrowFunctionExpression=function(h){va(h)&&c(a.getScope())},t}},"exhaustive-deps":{meta:{type:"suggestion",docs:{description:"verifies the list of dependencies for Hooks like useEffect and similar",recommended:!0,url:"https://github.com/facebook/react/issues/14920"},fixable:"code",hasSuggestions:!0,schema:[{type:"object",additionalProperties:!1,enableDangerousAutofixThisMayCauseInfiniteLoops:!1,
properties:{additionalHooks:{type:"string"},enableDangerousAutofixThisMayCauseInfiniteLoops:{type:"boolean"}}}]},create:function(a){function c(m){v&&Array.isArray(m.suggest)&&0<m.suggest.length&&(m.fix=m.suggest[0].fix);a.report(m)}function f(m,p){return function(w){if(p.has(w))return p.get(w);var k=m(w);p.set(w,k);return k}}function q(m,p,w,k,n){function D(b){var d=N(b.references),e;try{for(d.s();!(e=d.n()).done;){var g=e.value;if(g.resolved&&S.has(g.resolved.scope)){var r=Ia(m,g.identifier),u=Ca(r),
W=Z(u,fa),ea;if(ea=n&&"Identifier"===u.type&&("MemberExpression"===u.parent.type||"OptionalMemberExpression"===u.parent.type)&&!u.parent.computed&&"Identifier"===u.parent.property.type&&"current"===u.parent.property.name){for(var X=g.from,ka=!1;X.block!==m;)"function"===X.type&&(ka=null!=X.block.parent&&"ReturnStatement"===X.block.parent.type),X=X.upper;ea=ka}ea&&ia.set(W,{reference:g,dependencyNode:u});if("TSTypeQuery"!==u.parent.type&&"TSTypeReference"!==u.parent.type){var la=g.resolved.defs[0];
if(null!=la&&(null==la.node||la.node.init!==m.parent)&&"TypeParameter"!==la.type)if(Q.has(W))Q.get(W).references.push(g);else{var Fa=g.resolved,La=T(Fa)||ra(Fa);Q.set(W,{isStable:La,references:[g]})}}}}}catch(sa){d.e(sa)}finally{d.f()}b=N(b.childScopes);var Ga;try{for(b.s();!(Ga=b.n()).done;)D(Ga.value)}catch(sa){b.e(sa)}finally{b.f()}}function H(b){b=b.split(".");for(var d="",e=0;e<b.length;e++){if(0!==e){var g=b.slice(0,e+1).join(".");g=!0===fa.get(g);d+=g?"?.":"."}d+=b[e]}return d}function I(b,
d,e,g){return 0===b.size?null:(1<b.size?"":d+" ")+e+" "+(1<b.size?"dependencies":"dependency")+": "+Ka(Array.from(b).sort().map(function(r){return"'"+H(r)+"'"}))+(". Either "+g+" "+(1<b.size?"them":"it")+" or remove the dependency array.")}n&&m.async&&c({node:m,message:"Effect callbacks are synchronous to prevent race conditions. Put the async function inside:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching"});
for(var J=t.acquire(m),S=new Set,R=null,P=J.upper;P;){S.add(P);if("function"===P.type)break;P=P.upper}if(P){R=P;var ca=Array.isArray,T=f(function(b){if(!ca(b.defs))return!1;var d=b.defs[0];if(null==d||"VariableDeclarator"!==d.node.type)return!1;var e=d.node.init;if(null==e)return!1;for(;"TSAsExpression"===e.type||"AsExpression"===e.type;)e=e.expression;var g=d.node.parent;if(null==g&&(Ia(R.block,d.node.id),g=d.node.parent,null==g))return!1;if("const"===g.kind&&"Literal"===e.type&&("string"===typeof e.value||
"number"===typeof e.value||null===e.value))return!0;if("CallExpression"!==e.type)return!1;e=e.callee;"MemberExpression"!==e.type||"React"!==e.object.name||null==e.property||e.computed||(e=e.property);if("Identifier"!==e.type)return!1;d=d.node.id;g=e.name;if("useRef"===g&&"Identifier"===d.type)return!0;e="Identifier"===e.type&&"useEffectEvent"===e.name;if(e&&"Identifier"===d.type){b=N(b.references);var r;try{for(b.s();!(r=b.n()).done;){var u=r.value;u!==d&&M.add(u.identifier)}}catch(W){b.e(W)}finally{b.f()}return!0}if("useState"===
g||"useReducer"===g){if("ArrayPattern"===d.type&&2===d.elements.length&&ca(b.identifiers)){if(d.elements[1]===b.identifiers[0]){if("useState"===g)for(r=b.references,b=u=0;b<r.length;b++){r[b].isWrite()&&u++;if(1<u)return!1;h.set(r[b].identifier,d.elements[0])}return!0}if(d.elements[0]===b.identifiers[0]&&"useState"===g)for(d=b.references,r=0;r<d.length;r++)z.add(d[r].identifier)}}else if("useTransition"===g&&"ArrayPattern"===d.type&&2===d.elements.length&&Array.isArray(b.identifiers)&&d.elements[1]===
b.identifiers[0])return!0;return!1},K),ra=f(function(b){if(!ca(b.defs))return!1;b=b.defs[0];if(null==b||null==b.node||null==b.node.id)return!1;var d=b.node,e=R.childScopes;b=null;var g;for(g=0;g<e.length;g++){var r=e[g],u=r.block;if("FunctionDeclaration"===d.type&&u===d||"VariableDeclarator"===d.type&&u.parent===d){b=r;break}}if(null==b)return!1;for(g=0;g<b.through.length;g++)if(d=b.through[g],null!=d.resolved&&S.has(d.resolved.scope)&&!T(d.resolved))return!1;return!0},x),ia=new Map,Q=new Map,fa=
new Map;D(J);ia.forEach(function(b,d){var e=b.dependencyNode;b=b.reference.resolved.references;for(var g=!1,r=0;r<b.length;r++){var u=b[r].identifier.parent;if(null!=u&&"MemberExpression"===u.type&&!u.computed&&"Identifier"===u.property.type&&"current"===u.property.name&&"AssignmentExpression"===u.parent.type&&u.parent.left===u){g=!0;break}}g||c({node:e.parent.property,message:"The ref value '"+d+".current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy '"+
(d+".current' to a variable inside the effect, and use that variable in the cleanup function.")})});var Y=new Set,aa=new Set;Q.forEach(function(b,d){var e=b.references;b.isStable&&aa.add(d);e.forEach(function(g){g.writeExpr&&(g=g.writeExpr,Y.has(d)||(Y.add(d),c({node:g,message:"Assignments to the '"+d+"' variable from inside React Hook "+(a.getSource(w)+" will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside ")+
(a.getSource(w)+".")})))})});if(!(0<Y.size))if(p){var F=[],ba=new Set;"ArrayExpression"!==p.type?c({node:p,message:"React Hook "+a.getSource(w)+" was passed a dependency list that is not an array literal. This means we can't statically verify whether you've passed the correct dependencies."}):p.elements.forEach(function(b){if(null!==b)if("SpreadElement"===b.type)c({node:b,message:"React Hook "+a.getSource(w)+" has a spread element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies."});
else{M.has(b)&&c({node:b,message:"Functions returned from `useEffectEvent` must not be included in the dependency array. Remove `"+(a.getSource(b)+"` from the list."),suggest:[{desc:"Remove the dependency `"+a.getSource(b)+"`",fix:function(r){return r.removeRange(b.range)}}]});try{var d=Z(b,null)}catch(r){if(/Unsupported node type/.test(r.message)){"Literal"===b.type?Q.has(b.value)?c({node:b,message:"The "+b.raw+" literal is not a valid dependency because it never changes. Did you mean to include "+
(b.value+" in the array instead?")}):c({node:b,message:"The "+b.raw+" literal is not a valid dependency because it never changes. You can safely remove it."}):c({node:b,message:"React Hook "+a.getSource(w)+" has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked."});return}throw r;}for(var e=b;"MemberExpression"===e.type||"OptionalMemberExpression"===e.type||"ChainExpression"===e.type;)e=e.object||e.expression.object;var g=!R.through.some(function(r){return r.identifier===
e});F.push({key:d,node:b});g||ba.add(d)}});var L=za({dependencies:Q,declaredDependencies:F,stableDependencies:aa,externalDependencies:ba,isEffect:n});P=L.unnecessaryDependencies;var U=L.missingDependencies,ja=L.duplicateDependencies,da=L.suggestedDependencies;if(0===ja.size+U.size+P.size)Aa({declaredDependencies:F,declaredDependenciesNode:p,componentScope:R,scope:J}).forEach(function(b){var d=b.construction,e=b.isUsedOutsideOfHook;b=b.depType;var g="function"===b?"useCallback":"useMemo",r="function"===
b?"definition":"initialization",u="wrap the "+r+" of '"+d.name.name+"' in its own "+g+"() Hook.";u="The '"+d.name.name+"' "+b+" "+("conditional"===b||"logical expression"===b?"could make":"makes")+" the dependencies of "+(k+" Hook (at line "+p.loc.start.line+") change on every render. ")+(e?"To fix this, "+u:"Move it inside the "+k+" callback. Alternatively, "+u);var W;e&&"Variable"===d.type&&"function"===b&&(W=[{desc:"Wrap the "+r+" of '"+d.name.name+"' in its own "+g+"() Hook.",fix:function(ea){var X=
"useMemo"===g?["useMemo(() => { return ","; })"]:["useCallback(",")"],ka=X[1];return[ea.insertTextBefore(d.node.init,X[0]),ea.insertTextAfter(d.node.init,ka)]}}]);c({node:d.node,message:u,suggest:W})});else{!n&&0<U.size&&(da=za({dependencies:Q,declaredDependencies:[],stableDependencies:aa,externalDependencies:ba,isEffect:n}).suggestedDependencies);(function(){if(0===F.length)return!0;var b=F.map(function(e){return e.key}),d=b.slice().sort();return b.join(",")===d.join(",")})()&&da.sort();L="";if(0<
P.size){var l=null;Array.from(P.keys()).forEach(function(b){null===l&&b.endsWith(".current")&&(l=b)});if(null!==l)L=" Mutable values like '"+l+"' aren't valid dependencies because mutating them doesn't re-render the component.";else if(0<ba.size){var B=Array.from(ba)[0];J.set.has(B)||(L=" Outer scope values like '"+B+"' aren't valid dependencies because mutating them doesn't re-render the component.")}}if(!L&&U.has("props")){J=Q.get("props");if(null==J)return;J=J.references;if(!Array.isArray(J))return;
B=!0;for(var A=0;A<J.length;A++){var y=Ia(R.block,J[A].identifier);if(!y){B=!1;break}y=y.parent;if(null==y){B=!1;break}if("MemberExpression"!==y.type&&"OptionalMemberExpression"!==y.type){B=!1;break}}B&&(L=" However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the "+(k+" call and refer to those specific props inside ")+(a.getSource(w)+"."))}if(!L&&0<U.size){var E=null;U.forEach(function(b){if(!E){var d=R.set.get(b),e=Q.get(b);if(e.references[0].resolved===
d&&(d=d.defs[0],null!=d&&null!=d.name&&"Parameter"===d.type)){d=!1;for(var g,r=0;r<e.references.length;r++)if(g=e.references[r].identifier,null!=g&&null!=g.parent&&("CallExpression"===g.parent.type||"OptionalCallExpression"===g.parent.type)&&g.parent.callee===g){d=!0;break}d&&(E=b)}}});null!==E&&(L=" If '"+E+"' changes too often, find the parent component that defines it and wrap that definition in useCallback.")}if(!L&&0<U.size){var C=null;U.forEach(function(b){if(null===C)for(var d=Q.get(b).references,
e,g,r=0;r<d.length;r++){e=d[r].identifier;for(g=e.parent;null!=g&&g!==R.block;){if("CallExpression"===g.type){var u=h.get(g.callee);if(null!=u){u.name===b?C={missingDep:b,setter:g.callee.name,form:"updater"}:z.has(e)?C={missingDep:b,setter:g.callee.name,form:"reducer"}:(e=d[r].resolved,null!=e&&(e=e.defs[0],null!=e&&"Parameter"===e.type&&(C={missingDep:b,setter:g.callee.name,form:"inlineReducer"})));break}}g=g.parent}if(null!==C)break}});if(null!==C)switch(C.form){case "reducer":L=" You can also replace multiple useState variables with useReducer if '"+
(C.setter+"' needs the current value of '")+(C.missingDep+"'.");break;case "inlineReducer":L=" If '"+C.setter+"' needs the current value of '"+(C.missingDep+"', you can also switch to useReducer instead of useState and read '")+(C.missingDep+"' in the reducer.");break;case "updater":L=" You can also do a functional update '"+C.setter+"("+C.missingDep.slice(0,1)+" => ...)' if you only need '"+C.missingDep+"' in the '"+(C.setter+"' call.");break;default:throw Error("Unknown case.");}}c({node:p,message:"React Hook "+
a.getSource(w)+" has "+(I(U,"a","missing","include")||I(P,"an","unnecessary","exclude")||I(ja,"a","duplicate","omit"))+L,suggest:[{desc:"Update the dependencies array to be: ["+da.map(H).join(", ")+"]",fix:function(b){return b.replaceText(p,"["+da.map(H).join(", ")+"]")}}]})}}else{var O=null;Q.forEach(function(b,d){O||b.references.forEach(function(e){if(!O&&h.has(e.identifier)){for(e=e.from;"function"!==e.type;)e=e.upper;e.block===m&&(O=d)}})});if(O){var ta=za({dependencies:Q,declaredDependencies:[],
stableDependencies:aa,externalDependencies:new Set,isEffect:!0}).suggestedDependencies;c({node:w,message:"React Hook "+k+" contains a call to '"+O+"'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass ["+ta.join(", ")+("] as a second argument to the "+k+" Hook."),suggest:[{desc:"Add dependencies array: ["+ta.join(", ")+"]",fix:function(b){return b.insertTextAfter(m,", ["+ta.join(", ")+"]")}}]})}}}}var v=a.options&&a.options[0]&&a.options[0].enableDangerousAutofixThisMayCauseInfiniteLoops||
!1,G={additionalHooks:a.options&&a.options[0]&&a.options[0].additionalHooks?new RegExp(a.options[0].additionalHooks):void 0,enableDangerousAutofixThisMayCauseInfiniteLoops:v},t=a.getSourceCode().scopeManager,h=new WeakMap,z=new WeakSet,K=new WeakMap,x=new WeakMap,M=new WeakSet;return{CallExpression:function(m){var p=Ha(m.callee,G);if(-1!==p){var w=m.arguments[p],k=m.callee,n=Ea(k).name;m=m.arguments[p+1];var D=!m||"Identifier"===m.type&&"undefined"===m.name?void 0:m;m=/Effect($|[^a-z])/g.test(n);
if(w)if(D||m){switch(w.type){case "FunctionExpression":case "ArrowFunctionExpression":q(w,D,k,n,m);return;case "Identifier":if(!D||D.elements&&D.elements.some(function(H){return H&&"Identifier"===H.type&&H.name===w.name}))return;p=a.getScope().set.get(w.name);if(null==p||null==p.defs)return;p=p.defs[0];if(!p||!p.node)break;if("Variable"!==p.type&&"FunctionName"!==p.type)break;switch(p.node.type){case "FunctionDeclaration":q(p.node,D,k,n,m);return;case "VariableDeclarator":if(p=p.node.init)switch(p.type){case "ArrowFunctionExpression":case "FunctionExpression":q(p,
D,k,n,m);return}}break;default:c({node:k,message:"React Hook "+n+" received a function whose dependencies are unknown. Pass an inline function instead."});return}c({node:k,message:"React Hook "+n+" has a missing dependency: '"+w.name+"'. Either include it or remove the dependency array.",suggest:[{desc:"Update the dependencies array to be: ["+w.name+"]",fix:function(H){return H.replaceText(D,"["+w.name+"]")}}]})}else"useMemo"!==n&&"useCallback"!==n||c({node:k,message:"React Hook "+n+" does nothing when called with only one argument. Did you forget to pass an array of dependencies?"});
else c({node:k,message:"React Hook "+n+" requires an effect callback. Did you forget to pass a callback to the hook?"})}}}}}};

//# sourceMappingURL=eslint-plugin-react-hooks.production.min.js.map
